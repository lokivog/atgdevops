input {
	file {
		path => [ 
			"SERVER"
	 	]
    type => "jboss"
    start_position => "beginning"
 	}
}

filter {

	if [type] == "jboss" {

		multiline {
		    #match the jboss timestamp and combine all lines up to the next jboss timestamp
	  		pattern => "(?>\d\d){1,2}-(?:0?[1-9]|1[0-2])-(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])[T ](?:2[0123]|[01]?[0-9])(?::?(?:(?:[0-5][0-9]|60)(?:[:.,][0-9]+)?))"
	  		negate => true
	  		add_tag => [ "multiline" ]
	  		what => "previous"
		}

		grok {
		    #match jboss log message as [timestamp] [loglevel] [className] [message]
			match => ["message", "%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{LOGLEVEL:level}\s+\[%{DATA:className}\]%{SPACE}%{GREEDYDATA:message}"]
		 	add_tag => ["standard_msg"]
		 	add_field => ["env","dev"]
		 	add_field => ["site","b2c"]
		}
		
		if [level] not in ["ERROR","WARN"] {
			#if log message is not ERROR or WARN then drop
			#comment out to log all messages
			drop {}
		}
		
		if [className] == "org.jboss.kernel.plugins.dependency.InstallAction" or [className] == "STDERR"  { 
			#drop InstallAction warning that get fired when the server is shutting down
			drop {}
    	}

		ruby {
  			#trim a multiline message to "N" lines
  			code => "event['message'] = event['message'][0].lines.to_a[0,15].join;"
  			tags => ["multiline"]
		}

		grok {
	  		# extract jboss server name from log file path
	  		match => ["path", "server\/(?<server>\w*)"]
		}

		date { 
	  		#normalize logstash timestamp from jboss timestamp
	  		match => ["timestamp","yyyy-MM-dd HH:mm:ss,SSS"]
		}
	}
}

output {
  
	elasticsearch {
	   # Setting 'embedded' will run  a real elasticsearch server inside logstash.
	   # This option below saves you from having to run a separate process just
	   # for ElasticSearch, so you can get started quicker!
	   #embedded => true
	   host => "localhost"
	}
	stdout { codec => rubydebug }
}

